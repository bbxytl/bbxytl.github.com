[**GitHubBlog**](https://github.com/bbxytl/bbxytl.github.com/tree/master/blog#home--githubblog) /
=====
#[C++Primer学习笔记（一）](https://github.com/bbxytl/bbxytl.github.com/blob/master/blog/pages/6_C++Primer学习笔记（一）.md#githubblog-)

- 在类中，任何自定义名为**`this`**的参数或者变量的行为都是非法的。因为`this`的目的总是指向”这个“对象，所以`this`是一个常量指针，我们不允许改变`this`中保存的地址。
- **常量对象**，以及常量对象的引用或指针都只能调用常量成员函数。
-  一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件即可。
-  因为`IO`类属于不能被拷贝的类型，因此我们只能通过引用来传递它们。拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包含`IO`类型在内）根本就不支持拷贝操作。当某种类类型根本不支持拷贝操作时，此时函数就只能通过**引用形参**访问该类型的对象。
- 不同于其他成员函数，**构造函数不能被声明为`const`**的。当我们创建一个类的`const`对象时，直到构造函数完成初始化后，对象才能真正的取得其”常量“属性。因此，构造函数在`const`对象的构造过程中可以向其写值。
- C++11新标准中，如果我们需要一个显式的默认构造函数，可以通过在参数列表后面写上** `= default`** 来要求编译器生成一个。其中 `= default` 既可以和声明一起出现在类的内部，此时默认构造函数为内联的；也可以作为定义出现在类的外部，此时，该成员默认情况不是内联的。构造函数中出现如下的形式：
```cpp
ClassName( ) = default ;
// 因为该构造函数不接受任何实参，所以它是一个默认构造函数。
// 定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。
// 我们希望这个函数的作用完全等同于之前使用的合成的默认构造函数。
```
- **默认构造函数**要想有效，类中的成员变量需要提供初始值，特别的内置类型的成员变量必须有初始值。如果编译器不支持类内的初始值，那么默认构造函数就应该使用构造函数的初始值列表来初始化成员变量。如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。在实际中，如果提供了其他构造函数，最好也提供一个默认构造函数。
- 使用**初始化列表**时，初始化顺序不是根据初始化表中的顺序进行初始化的，而是根据成员变量在类内声明的顺序进行顺序初始化的。构造函数不应该轻易覆盖掉类内的初始值，除非新赋值与原值不同。如果不能使用类内初始化，则所有的构造函数都应该显式地初始化每个内置类型的成员。初始化`const` 或者引用类型的数据成员的唯一机会就是通过构造函数初始值。即如果成员是`const` 、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。
- 类可以允许其他类或这函数访问它的非公有成员，方法是将其他类或者函数声明为该类的**友元**。在类中增加一条以`friend`关键字开头的函数声明即可。友元声明只能出现在类定义的内部（说明在其实现地方不需要加此关键字！），但其不是类的成员，所以不受所在区域访问控制级别的约束，即出现位置随意。但一般最好在类定义开始或者结束前的位置集中声明友元。同时，友元的声明并不是一个正式的函数（类）声明，所以必须在类外再专门对函数进行一次声明。通常将类与其友元放在同一个文件中。**友元关系是不具有传递性的！**
- 要想让某个成员函数作为友元，必须仔细组织程序结构以满足声明和定义的彼此依赖关系。如在`B`类中有一个友元成员函数是类`A`的成员函数`fun()`，则必须安装如下方式设计程序：
    - 首先定义类`A` ，其中声明 `fun()` 函数，但是不能定义它。在 `fun()` 使用 类`B` 的成员之前必须先声明 类 `B` 。
    - 接下来定义类 `B` ，包括对于 `fun()` 的友元声明。
    - 最后定义 `fun()` ，此时它猜可以使用类 `B` 的成员。
```cpp
class B; //必须先声明
class A {
public:
    void fun(B &b); 
    ~~~~~~
}
class B {
public:
    friend void A::fun(B &b);
    ~~~~~~~
}
//最后定义 A::fun(B &b)
```
- 友元函数或类必须在类外提供相应的声明从而使得函数可见，即使该友元函数是在类内进行定义的！如下例子：
```cpp
struct X {
    friend void f() {  /* 友元函数可以定义在类的内部 */ }
    X() { f(); }                                    // 错误：f 还没有被声明
    void g();
    void h();
};
void X::g() { return f(); }             // 错误： f 还没有被声明
void f();                                       // 声明那个定义在X中的函数
void X::h() { return f(); }             // 正确：现在f的声明在作用域中了
```
- 定义在类内部的成员函数是自动**内联的（inline）**。我们可以在类的内部把`inline`作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用`inline`关键字修饰函数的定义。`inline `成员函数最好也应该与相应的类定义在同一个头文件中。
- 可以通过在成员变量的声明中加入 `mutalble` 关键字来在一个 `const` 成员函数内修改该成员变量。此时此成员变量称为：**可变数据成员**。一个可变数据成员永远不会是 `const` 。即使它是 `const` 对象的成员。
- (C++11)当提供一个类内初始值时，必须以符号**=** 或者**花括号**表示。
- 返回**`*this`**的成员函数，返回值应该是对象引用！否则返回的将是`*this`的临时副本。同时，一个`const`成员函数如果以引用的形式返回**`*this`**，那么它的返回类型将是常量引用。
- **前向声明**的类是一个不完全类型。只能在非常有限的情景下使用：可以定义指向这种类型的指针或者引用，也可以声明（但不能定义）以不完全类型作为参数或者返回类型的函数。一个类的成员类型不能是该类自身。因为只有当类全部完成后类才算被定义，编译器才能了解这样的对象需要多少存储空间。然而，一旦一个类的名字出现后，就被认为是声明过了（但尚未定义），因此可以使用指向其自身的引用或者指针。
- 函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。
- 编译器处理完类中的全部声明后才会处理成员函数的定义。一般来说，内层**作用域**可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。
- 编译器只会自动地执行一步类型转换。当需要两步或更多步自动转换时，编译器会报错。在要求隐式转换的程序中，可以通过在构造函数声明前使用关键字 **`explicit` **来阻止隐式转换。关键字 `explicit` 只对仅有一个参数的构造函数有效！因为需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 `explicit` 的，只能在类内声明构造函数时使用 `explicit` 关键字，在类外部定义时不应重复。当使用了此关键字后，它将只能以直接初始化的形式使用。而且编译器将不会在自动转换过程中使用该构造函数。即定义对象时就要进行初始化操作，不能使用拷贝（=）的形式进行初始化。尽管编译器不会将 `explicti` 的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式的强制进行转换：
```cpp
class A{
public:
    explicit A(const std::string &s);
    explicit A(std::istream &);
    A & combine(A&);
    ~~~~~~~
};

std::string str="asddf";
A item(str) ;          // 正确：直接初始化
A item2 = str;      //  错误：不能将 explicit 构造函数用于拷贝形式的初始化过程

item.combine(A(str));   // 正确：实参是一个显式构造的 A 对象
item.combine(static_cast<A>(cin));      // 正确：static_cast 可以使用 explicit 的构造函数
```
- **聚合类**满足以下条件：
    - 所有成员都是 public 的；
    - 没有定义任何构造函数；
    - 没有类内初始值；
    - 没有基类，也没有 virtual 函数。
- 结构体就相当于一个**聚合类**。聚合类可以使用花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员。初始值的顺序必须与声明顺序一致。
- **字面值常量类**：数据成员都是字面值类型的聚合类是字面值常量类。如果类不是聚合类，则要符合以下条件：
    - 数据成员必须都是字面值类型；
    - 类必须至少含有一个 constexpr 构造函数；
    - 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的 `constexpr` 构造函数；
    - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。
- 一个**字面值常量类必须至少提供一个  `constexpr` 构造函数**。同时，`constexpr` 构造函数可以声明为 `= default` 的形式或者是删除函数的形式。否则，由于`constexpr` 构造函数是一个构造函数，所以不能包含return语句，又因为其是一个`constexpr`函数，函数体能包含的语句只能是return语句，所以一般，`constexpr`构造函数的函数体为空。
- 类的静态成员存在于类的任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定子啊一起，它们不包含`this`指针。作为结果，静态成员函数不能声明为 `const` 的，而且我们也不能在 `static ` 函数体内使用`this `指针。可以使用作用域运算符来直接访问类的静态成员。虽然静态成员不属于类的某个对象，但扔可以通过类的对象、引用或指针来访问静态成员。当在类外部定义静态成员时，不能重复使用`static` 关键字，该关键字只出现在类内部的声明语句。类的静态数据成员由于不属于类的任何对象，所以它们并不是在创建类对象时定义的，即不是由构造函数初始化的。而且不能在类的内部初始化静态成员，必须在类的外部初始化，一个静态数据成员只能定义一次！要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放到同一个文件中。
- **可以在类内为静态数据成员提供一个类内初始值，但必须是const整数类型的！**静态成员必须是字面值常量类型的constexpr。如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了。即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。
- **静态数据成员**可以是不完全类型，特别的，可以是它所属的类类型，而非静态数据成员则只能声明为它所属类的指针或引用。同时，静态数据成员可以作为默认实参！而非静态不行，因为它的值本身属于对象的一部分，这么做无法真实提供一个对象以便从中获取成员的值。如：
```cpp
class Screen {
public:
    // bkground 表示一个在类中稍后定义的静态成员
    Screen& clear(char = bkground);
private:
    static const char bkground;
};
```


##**附录**
- **[GitHub-Blog](http://bbxytl.github.io/)**
- **关注微信订阅号：LomperWay**：     
    ![关注微信订阅号](./images/qrcodes/qrcode_100.jpg)



